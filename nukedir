#!/usr/bin/env bash
#shellcheck disable=SC2034,SC1091,SC2155
# Fast-delete large directory trees using rsync optimization
set -euo pipefail

# Script metadata
VERSION='3.0.0'
PRG0=$(readlink -en -- "$0")
PRG="${PRG0##*/}"
readonly -- VERSION PRG

# Global variables
declare -i VERBOSE=1 DRYRUN=1

# Color support with terminal detection
if [[ -t 2 ]]; then
  declare -- RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -- RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi
readonly -- RED GREEN YELLOW CYAN NC

# --------------------------------------------------------------------------------
# Core message functions

# Main message function using FUNCNAME for context
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$PRG:" msg
  case "$status" in
    error)   prefix+=" ${RED}âœ—${NC}" ;;
    info)    prefix+=" ${CYAN}info:${NC}" ;;
    warn)    prefix+=" ${YELLOW}warn:${NC}" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

# Standard message functions
error()   { >&2 _msg "$@"; }
info()    { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn()    { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
die()     { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

# --------------------------------------------------------------------------------
# Utility functions

# Command overrides (both used in script)
grep() { command grep "$@"; }
pgrep() { command pgrep "$@"; }

# Argument validation
noarg() { if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then die 2 "Missing argument for option '$1'"; fi; true; }
# --------------------------------------------------------------------------------
# Root requirement and cleanup

# This script requires root or sudo
((EUID)) && { sudo -ln &>/dev/null || die 1 "Requires root, or non-interactive sudo privileges."; exec sudo -n "$0" "$@"; exit 1; }

# Cleanup function
cleanup() {
  local -i exitcode=${1:-0}
  rm -rf "${BITBIN:-jUnK}"
  exit "$exitcode"
}
trap 'cleanup $?' SIGTERM SIGINT EXIT
# --------------------------------------------------------------------------------
# Main functions

usage() {
  cat <<EOT
$PRG $VERSION - Fast Delete Large Directory Trees

Description:
  Fast-delete ALL contents of a directory.
  Useful for deleting extremely large directories where
  'rm -rf' doesn't cut it. Requires root. Be very careful.

  Uses 'rsync --delete' from empty temporary directory.
  Optimizes deletion strategy based on filesystem type.
  
  *Default mode is --dryrun.*

Usage:
  $PRG [Options] dirname[ dirname [...]]

  dirname   Name/s of the directory trees to annihilate

Options:
  -n, --dryrun          Dryrun mode (default)
  -N, --notdryrun       Execute deletion
                        DRYRUN=$DRYRUN

  -T, --timeout N       Maximum time $PRG can run (default: no timeout)
                        Format: 2m (minutes), 4h (hours), etc.
  -i, --ionice 0|1|2|3  Use nice/ionice for I/O priority
                        0=no nice (default)
                        1=highest priority, 3=lowest

  -w, --wait-for-rsync  Do not execute until rsync is no longer running
  -r, --rsync-verbose   Use extra verbose mode for rsync
                         
  -v, --verbose         Be Verbose (default)
  -q, --quiet           Be Not Verbose (recommended with -N)
                        VERBOSE=$VERBOSE

  -V, --version         Print '$PRG $VERSION' and exit
  -h, --help            Print usage and exit

Examples:
  $PRG -T 4h /really/big/dir  # With 4 hour timeout

  $PRG -Nri 1 /really/really/big/dir  # Non-dryrun with highest I/O priority

  $PRG -wqN -i 1 "/oh/my/god/2027-06-{01..04}"  # Multiple directories

EOT
  exit "${1:-0}"
}

is_mount_point() { mountpoint -q "$1"; }

get_fs_type() {
  local -- path="$1"
  df -PT "$path" | awk 'NR==2 {print $2}'
}

# Global temporary directory
declare -- BITBIN="/tmp/${PRG}-$$-$RANDOM"

main() {
  local -- nuke_dir
  local -- verbose='v' dryrun='n' rsync_verbose=''
  local -i ionice=0 wait_for_rsync=0
  local -- timeout=''
  local -- rsync_bin='' timeout_bin='' nice_bin='' ionice_bin=''
  local -a rsync_cmd=()

  local -a nuke_dirs=()
  while (($#)); do case "$1" in
    -i|--ionice)    noarg "$@"; shift; ionice=$1 ;;
    -T|--timeout)   noarg "$@"; shift; timeout=$1;;
    -w|--wait-for-rsync)
                    wait_for_rsync=1 ;;
    -n|--dryrun)    DRYRUN=1; dryrun=n ;;
    -N|--notdryrun) DRYRUN=0; dryrun='' ;;
    -v|--verbose)   VERBOSE=1; verbose=v ;;
    -q|--quiet)     VERBOSE=0; verbose='' ;;
    -r|--rsync-verbose) rsync_verbose+='v' ;;
    -V|--version)   echo "$PRG $VERSION"; exit 0;;
    -h|--help)      usage 0 ;;
    -[iTwnNvqrVh]*) #shellcheck disable=SC2046 # expand aggregated short options
                    set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}";;
    -*)             die 22 "Invalid option $1" ;;
    *)              nuke_dirs+=( "${1}/" ) ;;
  esac; shift; done

  ((${#nuke_dirs[@]} == 0)) && { error 'No directory specified.'; usage 1 >&2; }

  [[ $PWD == '/' ]] && die 1 "Cannot execute from root directory"

  rsync_bin=$(command -v rsync) || die 1 "'rsync' not found"
  if ((ionice)); then
    # Validate ionice priority level (0-3)
    if ((ionice < 0 || ionice > 3)); then
      die 1 "Invalid ionice priority value: $ionice (must be 0-3)"
    fi
    ionice_bin=$(command -v ionice) || die 1 "'ionice' not found"
    nice_bin=$(command -v nice) || die 1 "'nice' not found"
  fi
  if [[ -n $timeout ]]; then
    timeout_bin=$(command -v timeout) || die 1 "'timeout' command not found"
  fi

  if pgrep -cx rsync >/dev/null; then
    warn "'rsync' is currently running $(pgrep -cx rsync) processes"
  fi

  # Make bitbin in /run if possible (tmpfs for better performance)
  if df -t tmpfs | grep -q '\s/run$'; then
    BITBIN="/run/${PRG}/bitbin-$$-$RANDOM"
  fi
  mkdir -p "$BITBIN" || die 1 "Could not create tempdir $BITBIN."
  info "BITBIN=$BITBIN"

  for nuke_dir in "${nuke_dirs[@]}"; do
    nuke_dir=$(readlink -en "$nuke_dir") || continue
    [[ "$nuke_dir" == '/' ]] && die 1 "ROOT directory CANNOT be specified!"
    [[ -d "$nuke_dir" ]] || { error "$nuke_dir is not a directory!"; continue; }
    is_mount_point "$nuke_dir" && die 1 "Cannot delete a mount point '$nuke_dir'!"

    waitforrsync

    ((! DRYRUN)) || info "<DRYRUN>"

    warn '***' "DELETING ALL CONTENTS OF $nuke_dir" '***'

    rsync_cmd=()
    if ((ionice)); then
      rsync_cmd=( "$nice_bin" -n -19 "$ionice_bin" -c1 -n0 "${rsync_cmd[@]}" )
    fi
    if [[ -n $timeout ]]; then
      rsync_cmd=( "$timeout_bin" '--kill-after=1s' "$timeout" "${rsync_cmd[@]}" )
    fi
    # Drop caches to free memory before deletion
    ((DRYRUN)) || { sync && echo 3 > /proc/sys/vm/drop_caches; }

    # Get filesystem type to optimize deletion strategy
    local -- fs_type
    fs_type=$(get_fs_type "$nuke_dir")
    info "Filesystem type: $fs_type"

    # Customize rsync options based on filesystem type
    local -- delete_opt="--delete-before"
    local -a extra_opts=("--no-inc-recursive" "--inplace")

    # XFS handles large deletes better with delete-during
    if [[ "$fs_type" == xfs ]]; then
      delete_opt="--delete-during"
    fi

    # Btrfs performs better with different options
    if [[ "$fs_type" == "btrfs" ]]; then
      delete_opt="--delete-delay"
      extra_opts+=("--preallocate")
    fi
    
    rsync_cmd+=( "$rsync_bin" "-a${rsync_verbose}${dryrun}" "$delete_opt" "${extra_opts[@]}" "${BITBIN:-jUnK}/" "${nuke_dir:-JuNk}/" )
    info "${rsync_cmd[*]}" "Executing..."

    # For extremely large directories, run in chunks to avoid memory issues
    if ((DRYRUN)); then
      "${rsync_cmd[@]}"
    else
      "${rsync_cmd[@]}" && rmdir "${nuke_dir:-jUnK}"
      # Ensure kernel caches are cleared after deletion
      sync
    fi

    ((! DRYRUN)) || info "</DRYRUN>"
    info "'$nuke_dir' has $( ((DRYRUN)) && echo -n 'NOT ' || echo -n '')been nuked"
  done
}

waitforrsync() {
  if ((wait_for_rsync)); then
    while pgrep -x rsync >/dev/null; do
      info 'Waiting for rsync process to finish.'
      sleep 60
    done
  fi
}

# --------------------------------------------------------------------------------
# Entry point

main "$@"

#fin
