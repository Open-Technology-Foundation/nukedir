#!/usr/bin/env bash
# Fast-delete large directory trees using rsync optimization
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

declare -r VERSION='3.1.0'
declare -r SCRIPT_NAME=nukedir

# --------------------------------------------------------------------------------
# Core message functions
declare -i VERBOSE=1

# Color support with terminal detection
if [[ -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

# Main message function using FUNCNAME for context
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$SCRIPT_NAME:" msg
  case "$status" in
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    warn)    prefix+=" ${YELLOW}▲${NC}" ;;
    success) prefix+=" ${GREEN}✓${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Standard message functions
info()  { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn()  { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
error() { >&2 _msg "$@"; }
die()   { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

# --------------------------------------------------------------------------------
# Utility functions

# Command overrides (both used in script)
grep() { command grep "$@"; }
pgrep() { command pgrep "$@"; }

# Argument validation
noarg() { if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then die 2 "Missing argument for option ${1@Q}"; fi; true; }

# This script requires root or sudo
if ((EUID)); then
  sudo -ln &>/dev/null || die 1 'Requires root, or non-interactive sudo privileges.'
  exec sudo -n "$0" "$@"
  exit 1
fi

# Cleanup function
cleanup() {
  rm -rf "${BITBIN:-jUnK}"
  exit "${1:-0}"
}
trap 'cleanup $?' SIGTERM SIGINT EXIT

# --------------------------------------------------------------------------------
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Fast Delete Large Directory Trees

Description:
  Fast-delete ALL contents of a directory.
  Useful for deleting extremely large directories where
  'rm -rf' doesn't cut it. Requires root. Be very careful.

  Uses 'rsync --delete' from empty temporary directory.
  Optimizes deletion strategy based on filesystem type.
  
  *Default mode is --dryrun.*

Usage:
  $SCRIPT_NAME [Options] dirname[ dirname [...]]

  dirname   Name/s of the directory trees to annihilate

Options:
  -n, --dryrun          Dryrun mode (default)
  -N, --notdryrun       Execute deletion
                        DRY_RUN=$DRY_RUN

  -T, --timeout N       Maximum time $SCRIPT_NAME can run (default: no timeout)
                        Format: 2m (minutes), 4h (hours), etc.
  -i, --ionice 0|1|2|3  Use nice/ionice for I/O priority
                        0=no nice (default)
                        1=highest priority, 3=lowest

  -w, --wait-for-rsync  Do not execute until rsync is no longer running
  -r, --rsync-verbose   Use extra verbose mode for rsync
                         
  -v, --verbose         Be Verbose (default)
  -q, --quiet           Be Not Verbose (recommended with -N)
                        VERBOSE=$VERBOSE

  -V, --version         Print '$SCRIPT_NAME $VERSION' and exit
  -h, --help            Print usage and exit

Examples:
  $SCRIPT_NAME -T 4h /really/big/dir  # With 4 hour timeout

  $SCRIPT_NAME -Nri 1 /really/really/big/dir  # Non-dryrun with highest I/O priority

  $SCRIPT_NAME -wqN -i 1 "/oh/my/god/2027-06-{01..04}"  # Multiple directories

EOT
}

is_mount_point() { mountpoint -q "$1"; }

get_fs_type() {
  local -- path=$1
  df -PT "$path" | awk 'NR==2 {print $2}'
}

wait_for_rsync() {
  if ((wait_for_rsync)); then
    while pgrep -x rsync >/dev/null; do
      info 'Waiting for rsync process to finish.'
      sleep 60
    done
  fi
}

declare -i DRY_RUN=1

# Global temporary directory
declare -- BITBIN=/tmp/"$SCRIPT_NAME"-"$$"-"$RANDOM"

main() {
  local -- nuke_dir
  local -- dryrun='n' rsync_verbose=''
  local -i ionice=0 wait_for_rsync=0
  local -- timeout=''
  local -- rsync_bin='' timeout_bin='' nice_bin='' ionice_bin=''
  local -a rsync_cmd=()

  local -a nuke_dirs=()
  while (($#)); do case $1 in
    -i|--ionice)    noarg "$@"; shift; ionice=$1 ;;
    -T|--timeout)   noarg "$@"; shift; timeout=$1;;
    -w|--wait-for-rsync)
                    wait_for_rsync=1 ;;
    -n|--dryrun)    DRY_RUN=1; dryrun=n ;;
    -N|--notdryrun) DRY_RUN=0; dryrun='' ;;
    -v|--verbose)   VERBOSE=1 ;;
    -q|--quiet)     VERBOSE=0 ;;
    -r|--rsync-verbose)
                    rsync_verbose+='v' ;;
    -V|--version)   echo "$SCRIPT_NAME $VERSION"; exit 0;;
    -h|--help)      usage; return 0 ;;
    -[iTwnNvqrVh]*) #shellcheck disable=SC2046 # expand aggregated short options
                    set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}";;
    -*)             die 22 "Invalid option ${1@Q}" ;;
    *)              nuke_dirs+=( "${1}/" ) ;;
  esac; shift; done

  ((${#nuke_dirs[@]})) || die 1 'No directory specified.'

  [[ $PWD == '/' ]] && die 1 'Cannot execute from root directory'

  rsync_bin=$(command -v rsync) || die 1 'rsync not found'
  if ((ionice)); then
    # Validate ionice priority level (0-3)
    if ((ionice < 0 || ionice > 3)); then
      die 1 "Invalid ionice priority value: $ionice (must be 0-3)"
    fi
    ionice_bin=$(command -v ionice) || die 1 "'ionice' not found"
    nice_bin=$(command -v nice) || die 1 "'nice' not found"
  fi
  if [[ -n $timeout ]]; then
    timeout_bin=$(command -v timeout) || die 1 "'timeout' command not found"
  fi

  if pgrep -cx rsync >/dev/null; then
    warn "'rsync' is currently running $(pgrep -cx rsync) processes"
  fi

  # Make bitbin in /run if possible (tmpfs for better performance)
  if df -t tmpfs | grep -q '\s/run$'; then
    BITBIN=/run/"$SCRIPT_NAME"/bitbin-"$$"-"$RANDOM"
  fi
  mkdir -p "$BITBIN" || die 1 "Could not create tempdir ${BITBIN@Q}"
  info "BITBIN=$BITBIN"

  for nuke_dir in "${nuke_dirs[@]}"; do
    nuke_dir=$(realpath -e "$nuke_dir") || continue
    [[ "$nuke_dir" == '/' ]] && die 1 'ROOT directory CANNOT be specified'
    [[ -d "$nuke_dir" ]] || { error "${nuke_dir@Q} is not a directory"; continue; }
    is_mount_point "$nuke_dir" && die 1 "Cannot delete a mount point ${nuke_dir@Q}"

    wait_for_rsync

    ((! DRY_RUN)) || info '<DRY_RUN>'

    warn '***' "DELETING ALL CONTENTS OF ${nuke_dir@Q}" '***'

    rsync_cmd=()
    if ((ionice)); then
      rsync_cmd=( "$nice_bin" -n -19 "$ionice_bin" -c1 -n0 "${rsync_cmd[@]}" )
    fi
    if [[ -n $timeout ]]; then
      rsync_cmd=( "$timeout_bin" '--kill-after=1s' "$timeout" "${rsync_cmd[@]}" )
    fi
    # Drop caches to free memory before deletion
    ((DRY_RUN)) || { sync && echo 3 > /proc/sys/vm/drop_caches; }

    # Get filesystem type to optimize deletion strategy
    local -- fs_type
    fs_type=$(get_fs_type "$nuke_dir")
    info "Filesystem type: $fs_type"

    # Customize rsync options based on filesystem type
    local -- delete_opt="--delete-before"
    local -a extra_opts=("--no-inc-recursive" "--inplace")

    # XFS handles large deletes better with delete-during
    if [[ "$fs_type" == xfs ]]; then
      delete_opt="--delete-during"
    fi

    # Btrfs performs better with different options
    if [[ "$fs_type" == "btrfs" ]]; then
      delete_opt="--delete-delay"
      extra_opts+=("--preallocate")
    fi
    
    rsync_cmd+=( "$rsync_bin" "-a${rsync_verbose}${dryrun}" "$delete_opt" "${extra_opts[@]}" "${BITBIN:-jUnK}/" "${nuke_dir:-JuNk}/" )
    info "${rsync_cmd[*]}" 'Executing...'

    # For extremely large directories, run in chunks to avoid memory issues
    if ((DRY_RUN)); then
      "${rsync_cmd[@]}"
    else
      "${rsync_cmd[@]}" && rmdir "${nuke_dir:-jUnK}"
      # Ensure kernel caches are cleared after deletion
      sync
    fi

    ((! DRY_RUN)) || info '</DRY_RUN>'
    info "'$nuke_dir' has $( ((DRY_RUN)) && echo -n 'NOT ' || echo -n '')been nuked"
  done
}

main "$@"
#fin
