#!/usr/bin/env bash
##shellcheck disable=SC2034,SC1091,SC2155
set -euo pipefail
readonly VERSION='3.0.0'
PRG0=$(readlink -en -- "$0")
readonly -- PRG="${PRG0##*/}"
declare -ix VERBOSE=1 DRYRUN=1
_log_() { 
  local -- level=$1 prefix=$2
  shift 2
  local -- msg fd=2
  if [[ -z $level ]]; then
    fd=1
  fi
  for msg in "$@"; do 
    printf '%s: %s%s\n' "$PRG" "$prefix" "$msg" >&$fd
  done
}
vecho() { ((VERBOSE)) && _log_ '' '' "$@"; }
vinfo() { ((VERBOSE)) && _log_ info 'info: ' "$@"; }
vwarn() { ((VERBOSE)) && _log_ warn 'warn: ' "$@"; }
error() { _log_ error 'error: ' "$@"; }
die() { local -i exitcode=${1:-1}; shift; if (($#)); then error "$@"; fi; exit "$exitcode"; }
grep() { /usr/bin/grep "$@"; }
pgrep() { /usr/bin/pgrep "$@"; }
declare -fx grep pgrep
noarg() { if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then die 2 "Missing argument for option '$1'"; fi; true; }
decp() { declare -p "$@" | sed 's/^declare -[a-z-]* //'; }
# This script *requires* root or sudo
((EUID)) && { sudo -ln &>/dev/null || die 1 "Requires root, or non-interactive sudo privileges."; exec sudo -n "$0" "$@"; exit 1; }
xcleanup() { local -i exitcode=${1:-0}; rm -rf "${BITBIN:-jUnK}"; exit "$exitcode"; }
trap 'xcleanup $?' SIGTERM SIGINT EXIT
# ----------------------------------------------------------------------------------------

usage() {
  cat <<EOT
$PRG $VERSION - Fast Delete Large Directory Trees

Description:
  Fast-delete ALL contents of a directory.
  Useful for deleting extremely large directories where
  'rm -rf' doesn't cut it. Requires root. Be very careful.

  Uses 'rsync --delete' from empty temporary directory.
  Optimizes deletion strategy based on filesystem type.
  
  *Default mode is --dryrun.*

Usage:
  $PRG [Options] dirname[ dirname [...]]

  dirname   Name/s of the directory trees to annihilate

Options:
  -n, --dryrun          Dryrun mode (default)
  -N, --notdryrun       Execute deletion
                        $(decp DRYRUN)

  -T, --timeout N       Maximum time $PRG can run (default: no timeout)
                        Format: 2m (minutes), 4h (hours), etc.
                        $(decp TIMEOUT)
  -i, --ionice 0|1|2|3  Use nice/ionice for I/O priority
                        0=no nice (default)
                        1=highest priority, 3=lowest
                        $(decp IONICE)

  -w, --wait-for-rsync  Do not execute until rsync is no longer running
  -r, --rsync-verbose   Use extra verbose mode for rsync
                        $(decp rsync_verbose)
                         
  -v, --verbose         Be Verbose (default)
  -q, --quiet           Be Not Verbose (recommended with -N)
                        $(decp VERBOSE)

  -V, --version         Print '$PRG $VERSION' and exit
  -h, --help            Print usage and exit

Examples:
  $PRG -T 4h /really/big/dir  # With 4 hour timeout

  $PRG -Nri 1 /really/really/big/dir  # Non-dryrun with highest I/O priority

  $PRG -wqN -i 1 "/oh/my/god/2027-06-{01..04}"  # Multiple directories

EOT
  exit "${1:-1}"
}

is_mount_point() { mountpoint -q "$1"; }

get_fs_type() {
  local -- path="$1"
  df -PT "$path" | awk 'NR==2 {print $2}'
}

declare -- BITBIN=/tmp/"$PRG"-"$$"-"$RANDOM"

main() {
  local -- NukeDir
  local -- verbose='v' dryrun='n' rsync_verbose=''
  local -i IONICE=0 wait_for_rsync=0
  local -- TIMEOUT=''
  local -- RSYNCbin='' TIMEOUTbin='' NICEbin='' IONICEbin=''
  local -a RSYNC=()

  local -a NukeDirs=()
  while (($#)); do case "$1" in
    -i|--ionice)    noarg "$@"; shift; IONICE=$1 ;;
    -T|--timeout)   noarg "$@"; shift; TIMEOUT=$1;;
    -w|--wait-for-rsync)
                    wait_for_rsync=1 ;;
    -n|--dryrun)    DRYRUN=1; dryrun=n ;;
    -N|--notdryrun) DRYRUN=0; dryrun='' ;;
    -v|--verbose)   VERBOSE=1; verbose=v ;;
    -q|--quiet)     VERBOSE=0; verbose='' ;;
    -r|--rsync-verbose) rsync_verbose+='v' ;;
    -V|--version)   echo "$PRG $VERSION"; exit 0;;
    -h|--help)      usage 0 ;;
    -[iTwnNvqrVh]*) #shellcheck disable=SC2046 # expand aggregated short options
                    set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}";;
    -*)             die 22 "Invalid option $1" ;;
    *)              NukeDirs+=( "${1}/" ) ;;
  esac; shift; done

  (( ${#NukeDirs[0]} == 0 )) && { error "No directory specified." ; >&2 usage 1; }

  [[ $PWD == '/' ]] && die 1 "Cannot execute from root directory"

  RSYNCbin=$(command -v rsync) || die 1 "'rsync' not found"
  if ((IONICE)); then
    # Validate ionice priority level (0-3)
    if [[ $IONICE -lt 0 || $IONICE -gt 3 ]]; then
      die 1 "Invalid ionice priority value: $IONICE (must be 0-3)"
    fi
    IONICEbin=$(command -v ionice) || die 1 "'ionice' not found"
    NICEbin=$(command -v nice) || die 1 "'nice' not found"
  fi
  if [[ -n $TIMEOUT ]]; then
    TIMEOUTbin=$(command -v timeout) || die 1 "'timeout' command not found"
  fi

  if pgrep -cx rsync >/dev/null; then
    vwarn "'rsync' is currently running $(pgrep -cx rsync) processes"
  fi

  # make bitbin in /run if possible
  if df -t tmpfs | grep -q '\s/run$'; then
    BITBIN=/run/"$PRG"/bitbin-"$$"-"$RANDOM"
  fi
  mkdir -p "$BITBIN" || die 1 "Could not create tempdir $BITBIN."
  vinfo "BITBIN=$BITBIN"

  for NukeDir in "${NukeDirs[@]}"; do
    NukeDir=$(readlink -en "$NukeDir") || continue
    [[ "$NukeDir" == '/' ]] && die 1 "ROOT directory CANNOT be specified!"
    [[ -d "$NukeDir" ]] || { error "$NukeDir is not a directory!"; continue; }
    is_mount_point "$NukeDir" && die 1 "Cannot delete a mount point '$NukeDir'!"

    waitforrsync
    
    # We removed size estimation to improve performance on large directories

    ((! DRYRUN)) || vinfo "<DRYRUN>"

    vwarn '***' "DELETING ALL CONTENTS OF $NukeDir" '***'

    RSYNC=()
    if ((IONICE)); then
      RSYNC=( "$NICEbin" -n -19 "$IONICEbin" -c1 -n0 "${RSYNC[@]}" )
    fi
    if [[ -n $TIMEOUT ]]; then
      RSYNC=( "$TIMEOUTbin" '--kill-after=1s' "$TIMEOUT" "${RSYNC[@]}" )
    fi
    # Drop caches to free memory before deletion
    ((DRYRUN)) || { sync && echo 3 > /proc/sys/vm/drop_caches; }

    # Get filesystem type to optimize deletion strategy
    local -- FS_TYPE
    FS_TYPE=$(get_fs_type "$NukeDir")
    vinfo "Filesystem type: $FS_TYPE"
    
    # Customize rsync options based on filesystem type
    local -- DELETE_OPT="--delete-before"
    local -- EXTRA_OPTS=("--no-inc-recursive" "--inplace")
    
    # XFS handles large deletes better with delete-during
    if [[ "$FS_TYPE" == xfs ]]; then
      DELETE_OPT="--delete-during"
    fi

    # Btrfs performs better with different options
    if [[ "$FS_TYPE" == "btrfs" ]]; then
      DELETE_OPT="--delete-delay"
      EXTRA_OPTS+=("--preallocate")
    fi
    
    RSYNC+=( "$RSYNCbin" "-a${rsync_verbose}${dryrun}" "$DELETE_OPT" "${EXTRA_OPTS[@]}" "${BITBIN:-jUnK}/" "${NukeDir:-JuNk}/" )
    vinfo "${RSYNC[*]}" "Executing..."

    # For extremely large directories, run in chunks to avoid memory issues
    if ((DRYRUN)); then
      "${RSYNC[@]}"
    else
      "${RSYNC[@]}" && rmdir "${NukeDir:-jUnK}"
      # Ensure kernel caches are cleared after deletion
      sync
    fi

    ((! DRYRUN)) || vinfo "</DRYRUN>"
    vinfo "'$NukeDir' has $( ((DRYRUN)) && echo -n 'NOT ' || echo -n '')been nuked"
  done
}

waitforrsync() {
  if ((wait_for_rsync)); then
    while pgrep -x rsync > /dev/null; do
      vinfo "Waiting for rsync process to finish."
      sleep 60
    done
  fi
}

main "$@"
#fin
